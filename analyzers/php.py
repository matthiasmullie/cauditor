import subprocess
import container
from analyzers import abstract


class Analyzer(abstract.Analyzer):
    def __init__(self, project):
        super(Analyzer, self).__init__(project)

        config = container.load_config()
        self.pdepend_path = "{path}/{name}".format(path=config['analyzers']['pdepend_path'], name=project)

    def cleanup(self):
        """ Remove leftover files created in the process of analyzing """
        super(Analyzer, self).cleanup()
        subprocess.call("rm -rf {path}".format(path=self.pdepend_path), shell=True)

    def analyze(self):
        """ Analyse the commit
        :return: dict
        """
        # create path to store pdepend xml at
        subprocess.call("mkdir -p {path}".format(path=self.pdepend_path), shell=True)

        # run pdepend
        xml_path = "{pdepend_path}/pdepend.xml".format(pdepend_path=self.pdepend_path)
        cmd = "vendor/bin/pdepend --summary-xml={xml_path} {repo_path}".format(xml_path=xml_path, repo_path=self.path)
        subprocess.call(cmd, shell=True)

        # @todo allow folders/files to be excluded?

        # convert pdepend xml to useful data
        return self.convert(xml_path)

    def convert(self, path):
        """ convert pdepend's --summary-xml file to useful data
        :param path: string path of XML file generated by pdepend
        :return: dict
        """
        import xml.etree.ElementTree as etree

        tree = etree.parse(path)
        node = tree.getroot()  # root node: <metrics>

        return {
            'children': [self.package_data(child) for child in node.findall('package')],
            # executable lines of code
            'loc': int(node.attrib['eloc']),
            # number of classes & methods
            'noc': int(node.attrib['noc']),
            'nom': int(node.attrib['nom']),
        }

    def package_data(self, node):
        """ Read data from <package> node
        :param node: element
        :return: dict
        """
        return {
            'name': node.attrib['name'],
            'children': [self.class_data(child) for child in node.findall('class')],
        }

    def class_data(self, node):
        """ Read data from <class> node
        :param node: element
        :return: dict
        """
        return {
            'name': node.attrib['name'],
            'children': [self.method_data(child) for child in node.findall('method')],
            # executable lines of code
            'loc': int(node.attrib['eloc']),
            # afferent coupling
            'ca': int(node.attrib['ca']),
            # efferent coupling
            'ce': int(node.attrib['ce']),
            # instability
            'i': int(node.attrib['ce']) / ((int(node.attrib['ce']) + int(node.attrib['ca'])) or 1),
            # depth of inheritance tree
            'dit': int(node.attrib['dit']),
        }

    def method_data(self, node):
        """ Read data from <method> node
        :param node: element
        :return: dict
        """
        return {
            'name': node.attrib['name'],
            # executable lines of code
            'loc': int(node.attrib['eloc']),
            # extended cyclomatic complexity
            'ccn': int(node.attrib['ccn2']),
            # npath complexity
            'npath': int(node.attrib['npath']),

            # below metrics need https://github.com/pdepend/pdepend/pull/198
            # halstead effort
            'he': float(node.attrib['he']),
            # halstead intelligent content
            'hi': float(node.attrib['hi']),
            # maintainability index
            'mi': float(node.attrib['mi']),
        }
